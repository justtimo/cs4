package com.wby.cs4.ch1.排序.child5快速排序;

/**
 * @Auther: LangWeiXian
 * @Date: 2021/10/26 14:17
 * @Description: 快速排序 是原地排序,只需要很小的辅助栈 ,且长度为N的数组排序所需时间和NlogN成正比.
 *
 * 之前的排序都无法将这两个优点结合起来. 且快排的内循环比大多数的排序算法都要短小,这意味着他很快
 *
 * 快排是一种分治的排序算法. 他将一个数组分成两个子数组,将两部分独立排序.
 * 快排和归并排序是互补的:
 *      归并将数组分成两个子数组分别排序,并将有序的子数组归并以将整个数组排序;
 *      快排 将数组排序的方式 是: 当两个子数组都有序时,整个数组也自然就有序了.
 * 归并排序中,数组被等分为两半 ; 快排中 ,切分的位置取决于数组的内容:
 *      1. 对于某个j ,a[j]已经排定( a[j]就是切分位置,使用partition()决定位置 )
 *      2. a[low] ~ a[j-1] 的元素 都不大于 a[j](切分点左边的元素都比切分点小)
 *      3. a[j+1] ~ a[hi] 中的元素都不小于 a[j](切分点右边的元素都比切分点大)
 *
 * 切分点选取策略:
 *      随意的取 a[low] 作为切分元素,然后从左端开始向右扫描直到找到一个大于等于他的元素 , 再从右端向左扫描找到一个小于等于他的元素,
 *     .两个元素是没有排定的 ,因此交换他们的位置.如此反复,我们就可以保证左指针i的左侧元素都不大于切分元素,右指针j的右侧元素都不小于切分
 *     元素. 两指针相遇时 ,我们只需要将切分元素 a[low]和左子数组最右侧的元素( a[j] )交换,然后返回j即可.
 */
public class QuikSort {
}
